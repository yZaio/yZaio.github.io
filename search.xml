<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2021/06/22/test/"/>
      <url>/2021/06/22/test/</url>
      
        <content type="html"><![CDATA[<section data-markdown="">     # 震惊！国内某数字消费资讯网站竟提供这种服务     * 🔧 效率工具推荐 &amp; 生产力技巧     * 💰 这些产品值得买     * 🔭 这个技术你会懂     * 👍 什么是最好的？ </section><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redux中使用immutable处理数据</title>
      <link href="/2021/06/21/redux-zhong-shi-yong-immutable-chu-li-shu-ju/"/>
      <url>/2021/06/21/redux-zhong-shi-yong-immutable-chu-li-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要使用immutableJS"><a href="#1-为什么要使用immutableJS" class="headerlink" title="1. 为什么要使用immutableJS"></a>1. 为什么要使用immutableJS</h2><p>​    我们知道在redux中reducer是一个纯函数，纯函数即：</p><ol><li><p>对于相同的输入，永远得到相同的输出</p></li><li><p>没有任何可观察到的副作用</p><p>那就是不能对传入进来的参数进行改变影响到原先的数据，在redux中的state我们就强调了数据不可变性，但当数据是引用类型的话，往往会造成一些问题，如：</p></li></ol><p>​    let obj = {name: ‘yang’}</p><p>​    let obj2 = obj</p><ul><li>我们明明没有修改obj，只是修改了obj2，但是最终obj也被我们修改掉了；</li><li>原因非常简单，对象是引用类型，它们指向同一块内存空间，两个引用都可以任意修改；</li></ul><p>有没有办法解决上面的问题呢？</p><ul><li>进行对象的拷贝即可：Object.assign或扩展运算符 </li></ul><p>这种对象的浅拷贝有没有问题呢？</p><ul><li><p>从代码的角度来说，没有问题，也解决了我们实际开发中一些潜在风险； </p></li><li><p>从性能的角度来说，有问题，如果对象过于庞大，这种拷贝的方式会带来性能问题以及内存浪费； </p></li></ul><p><font color="pink">所以为了解决这种性能问题及内存浪费，我们可以引进immutableJS</font></p><h2 id="2-认识immutableJS"><a href="#2-认识immutableJS" class="headerlink" title="2. 认识immutableJS"></a>2. 认识immutableJS</h2><ul><li><p>为了解决上面的问题，出现了Immutable对象的概念： </p><p>Immutable对象的特点是只要修改了对象，就会返回一个新的对象，旧的对象不会发生改变；</p><p>但是这样的方式就不会浪费内存了吗？</p></li><li><p>为了节约内存，又出现了一个新的算法：Persistent DataStructure（持久化数据结构或一致性数据结构）；</p><p>当然，我们一听到持久化第一反应应该是数据被保存到本地或者数据库，但是这里并不是这个含义： </p><ul><li>用一种数据结构来保存数据；</li><li>当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费； </li></ul></li></ul><p>如何做到这一点呢？结构共享</p><p>如下图：</p><p><img src="https://yzaio.gitee.io/medias/images/36.gif" alt=""></p><h2 id="3-immutableJS基本用法"><a href="#3-immutableJS基本用法" class="headerlink" title="3. immutableJS基本用法"></a>3. immutableJS基本用法</h2><p>JavaScript和ImmutableJS直接的转换</p><ul><li><p>对象转换成Immutable对象：Map； </p></li><li><p>数组转换成Immutable数组：List； </p></li><li><p>深层转换：fromJS； </p></li><li><p>Immutable类型转成：toJS()； </p></li></ul><p>ImmutableJS的基本操作： </p><ul><li><p>修改数据：set</p></li><li><p>获取数据：get</p></li></ul><h2 id="4-在redux中使用immutableJS"><a href="#4-在redux中使用immutableJS" class="headerlink" title="4. 在redux中使用immutableJS"></a>4. 在redux中使用immutableJS</h2><p>结合Redux管理数据：</p><ol><li><p>使用redux-immutable中的combineReducers； </p></li><li><p>所有的reducer中的数据都转换成Immutable类型的数据；</p></li></ol><h2 id="5-redux中使用immutableJS的好处"><a href="#5-redux中使用immutableJS的好处" class="headerlink" title="5. redux中使用immutableJS的好处"></a>5. redux中使用immutableJS的好处</h2><p>immutabl在修改复杂数据类型后 他会重新生成一个对象或者数组返回，不会影响到原来的，但是会尽可能使用原先的结构还有节点，保证性能上优化及内存的使用，如果不使用immutable的话，由于我们reducer是一个纯函数，不去影响到原先传进的state，所以每次数据有改变的时候，我们必须先拷贝一份state，再对其中需要修改的数据进行改变，再return出去，这样那些不需要修改的数据也被拷贝了这样大大的影响了性能和内存的占用，所以可以使用到immutable来对改变数据时进行相同节点的利用，只改变修改节点，再return一份新的出去，这样可以保证性能上的优化和内存的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react通过redux-hunk中间件实现网络请求数据在redux中进行管理</title>
      <link href="/2021/06/09/react-tong-guo-redux-hunk-zhong-jian-jian-shi-xian-wang-luo-qing-qiu-shu-ju-zai-redux-zhong-jin-xing-guan-li/"/>
      <url>/2021/06/09/react-tong-guo-redux-hunk-zhong-jian-jian-shi-xian-wang-luo-qing-qiu-shu-ju-zai-redux-zhong-jin-xing-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-react-hunk作用"><a href="#1-react-hunk作用" class="headerlink" title="1. react-hunk作用"></a>1. react-hunk作用</h2><p>原本redux的dispatch默认只能传一个对象，<strong>redux-thunk</strong>的作用就是使我们的dispatch支持传送一个函数，这样我们可以在这个函数中进行网络请求等相关操作了。</p><h2 id="2-redux-thunk使用步骤"><a href="#2-redux-thunk使用步骤" class="headerlink" title="2. redux-thunk使用步骤"></a>2. redux-thunk使用步骤</h2><p><img src="https://yzaio.gitee.io/medias/images/28.png" alt=""></p><p>在总的store管理进行以下操作：</p><ul><li><ol><li>从redux-thunk中接收默认导出的thunk</li><li>从redux中接收导出的applyMiddleware，他用于redux中使用中间件，可以传入多个中间件作为参数</li><li>把applyMiddleware（thunk）作为createStore的第二个参数传入，其中的composeEnhancers你们不用关注 ，那个是使用redux-devtools的方法，与redux-thunk无关</li></ol></li></ul><h2 id="3-页面通过redux管理数据步骤"><a href="#3-页面通过redux管理数据步骤" class="headerlink" title="3. 页面通过redux管理数据步骤"></a>3. 页面通过redux管理数据步骤</h2><ol><li>在每个功能模块我一般回给一个store，store里面有四个文件和其对应功能如下：</li></ol><p><img src="https://yzaio.gitee.io/medias/images/29.png" alt="">))</p><ol start="2"><li><p>在页面就可以通过dispatch传一个函数参数，在函数参数内部就可以进行网络请求等处理了</p><p><img src="https://yzaio.gitee.io/medias/images/30.png" alt=""></p><p><img src="https://yzaio.gitee.io/medias/images/31.png" alt=""></p><p><img src="https://yzaio.gitee.io/medias/images/32.png" alt=""></p></li><li><p>上面的<font color="pink">getTopBannersAction</font>和<font color="pink">changeTopBannersAction</font>方法就是在actionCreators里面执行的，接下来看下store其他三个文件的作用</p><ul><li><p>constants文件</p><p><img src="https://yzaio.gitee.io/medias/images/33.png" alt=""></p></li><li><p>reducer文件（<font color="gree">说明一下，这里我是通过immutable去管理对象，提升性能优化和内存使用，这里可以暂时不用这个，正常使用对象就行</font>）</p><p><img src="https://yzaio.gitee.io/medias/images/34.png" alt=""></p></li></ul></li></ol><ul><li><p>index文件</p><p><img src="https://yzaio.gitee.io/medias/images/35.png" alt=""></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流和防抖</title>
      <link href="/2021/05/21/jie-liu-he-fang-dou/"/>
      <url>/2021/05/21/jie-liu-he-fang-dou/</url>
      
        <content type="html"><![CDATA[<h2 id="1-节流"><a href="#1-节流" class="headerlink" title="1. 节流"></a>1. 节流</h2><h3 id="1-什么是节流"><a href="#1-什么是节流" class="headerlink" title="1. 什么是节流"></a>1. 什么是节流</h3><p>很多人都玩过类似于飞机大战的游戏（当然，这里只是举一个例子，为了方便大家理解，虽然大部分前端程序员并不做游戏，但是这个例子可以很好的解释节流函数）</p><p>在飞机大战的游戏中，我们按下空格会发射一个子弹：</p><ul><li>很多飞机大战的游戏中会有这样的设定，即使按下的频率非常快，子弹也会保持一定的频率来发射；（其实很多的街机游戏都是这样的，普通攻击有一个最高的频率）；</li><li>比如1秒钟只能发射一次，即使用户在这1秒钟按下了10次，子弹会保持发射一颗的频率来发射；</li><li>但是事件是触发了10次的，响应的函数只触发了一次；</li></ul><p>这就是节流的操作：</p><ul><li>在某个时间内（比如500ms），某个函数只能被触发一次；</li></ul><h3 id="2-节流的应用场景"><a href="#2-节流的应用场景" class="headerlink" title="2. 节流的应用场景"></a>2. 节流的应用场景</h3><ul><li><p>监听页面的滚动事件；</p></li><li><p>鼠标移动事件；</p></li><li><p>用户频繁点击按钮操作；</p></li><li><p>游戏中的一些设计；</p><p><font color="green">总之，依然是密集的事件触发，但是这次密集事件触发的过程，不会等待最后一次才进行函数调用，而是会按照一定的频率进行调用；</font></p></li></ul><h3 id="3-实现节流函数"><a href="#3-实现节流函数" class="headerlink" title="3. 实现节流函数"></a>3. 实现节流函数</h3><p>节流函数的默认实现思路我们采用时间戳的方式来完成：</p><ul><li><p>我们使用一个last来记录上一次执行的时间</p></li><li><ul><li>每次准备执行前，获取一下当前的时间now：<code>now - last &gt; interval（间隔等待时间）</code></li><li>那么函数执行，并且将now赋值给last即可</li></ul></li><li><pre><code>// fn 是需要执行的函数// interval 是时间间隔const throttle = (fn, interval = 50) =&gt; {  // 上一次执行 fn 的时间  let last = 0  // 将 throttle 处理结果当作函数返回  return function(...args) {    // 获取当前时间，转换成时间戳，单位毫秒    let now = +new Date()    // 将当前时间和上一次执行函数的时间进行对比    // 大于等待时间就把 previous 设置为当前时间并执行函数 fn    if (now - last &gt; interval) {      last = now      fn.apply(this, args)    }  }}// DEMO  // 执行 throttle 函数返回新函数  const betterFn = throttle(() =&gt; console.log('fn 函数执行了'), 2000)  // 每 0 毫秒执行一次 betterFn 函数，但是只有时间差大于 2000 时才会执行 fn  setInterval(betterFn, 0)<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在vue中如何试用此节流函数</span><br><span class="line"></span><br><span class="line">  1. 在外部utils定义该节流函数，方便全局使用</span><br></pre></td></tr></tbody></table></figure>// fn 是需要执行的函数// interval 是时间间隔const throttle = (fn, interval = 50) =&gt; {  // 上一次执行 fn 的时间  let last = 0  // 将 throttle 处理结果当作函数返回  return function(...args) {    // 获取当前时间，转换成时间戳，单位毫秒    let now = +new Date()    // 将当前时间和上一次执行函数的时间进行对比    // 大于等待时间就把 previous 设置为当前时间并执行函数 fn    if (now - last &gt; interval) {      last = now      fn.apply(this, args)    }  }}<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在data中定义一个事件变量，将此变量通过节流函数将原先需要进行的操作函数进行过滤后进行使用，即在aaa中进行原先需要的操作，给@click绑定过滤后的函数变量</span><br></pre></td></tr></tbody></table></figure>//html&lt;div @click="aaaClick"&gt;aaa&lt;/div&gt;//scriptdata() {  return {    aaaClick: null  }},beforeMount() {  this.aaaClick = throttle(this.aaa,2000)},methods: {      aaa() {        console.log('aaa点击了')      }}</code></pre></li></ul><h2 id="2-防抖"><a href="#2-防抖" class="headerlink" title="2. 防抖"></a>2. 防抖</h2><h2 id="1-什么是防抖"><a href="#1-什么是防抖" class="headerlink" title="1. 什么是防抖"></a>1. 什么是防抖</h2><p>​    比如我们等公交车，司机在每一个乘客上车后，就会再等待一分钟，如果1分钟没有乘客再继续上车就走了，如果重新上来一个乘客，就重新继续计时等待1分    钟，这就类似于防抖</p><p>比如想要搜索一个MacBook：</p><ul><li>当我输入m时，为了更好的用户体验，通常会出现对应的联想内容，这些联想内容通常是保存在服务器的，所以需要一次网络请求；</li><li>当继续输入ma时，再次发送网络请求；</li><li>那么macbook一共需要发送7次网络请求；</li><li>这大大损耗我们整个系统的性能，无论是前端的事件处理，还是对于服务器的压力；</li></ul><p>但是我们需要这么多次的网络请求吗？</p><ul><li>不需要，正确的做法应该是在合适的情况下再发送网络请求；</li><li>比如如果用户快速的输入一个macbook，那么只是发送一次网络请求；</li><li>比如如果用户是输入一个m想了一会儿，这个时候m确实应该发送一次网络请求；</li><li>也就是我们应该监听用户在某个时间，比如500ms内，没有再次触发时间时，再发送网络请求；</li></ul><p>这就是防抖的操作：</p><ul><li>只有在某个时间内，没有再次触发某个函数时，才真正的调用这个函数；</li></ul><p>我们用一副图来理解一下它的过程；</p><ul><li>当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间；</li><li>当事件密集触发时，函数的触发会被频繁的推迟；</li><li>只有等待了一段时间也没有事件触发，才会真正的执行响应函数；</li></ul><h3 id="2-防抖的应用场景"><a href="#2-防抖的应用场景" class="headerlink" title="2.防抖的应用场景"></a>2.防抖的应用场景</h3><ul><li>监听页面的滚动事件；</li><li>鼠标移动事件；</li><li>用户频繁点击按钮操作；</li><li>游戏中的一些设计；</li></ul><h3 id="3-实现防抖函数"><a href="#3-实现防抖函数" class="headerlink" title="3. 实现防抖函数"></a>3. 实现防抖函数</h3><pre><code>function debounce(fn, delay) { var timer = null; return function() {  if (timer) clearTimeout(timer);  *// 获取this和argument*  var _this = this;  var _arguments = arguments;  timer = setTimeout(function() {   *// 在执行时，通过apply来使用_this和_arguments*   fn.apply(_this, _arguments);  }, delay); }}</code></pre><h3 id="4-在vue里面使用防抖函数"><a href="#4-在vue里面使用防抖函数" class="headerlink" title="4.  在vue里面使用防抖函数"></a>4.  在vue里面使用防抖函数</h3><p>与节流函数相同，这里就不作示范了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue通过.sync实现父子组件传值双向绑定</title>
      <link href="/2021/05/13/vue-tong-guo-sync-shi-xian-fu-zi-zu-jian-chuan-zhi-shuang-xiang-bang-ding/"/>
      <url>/2021/05/13/vue-tong-guo-sync-shi-xian-fu-zi-zu-jian-chuan-zhi-shuang-xiang-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="1-普通父子组件传值"><a href="#1-普通父子组件传值" class="headerlink" title="1. 普通父子组件传值"></a>1. 普通父子组件传值</h2><p>​    正常vue父子组件传值中</p><ul><li>父组件向子组件传值：</li></ul><p>​    父组件通过在子组件标签上添加想要传送的属性即可，如下图：</p><p><img src="https://yzaio.gitee.io/medias/images/18.jpg" alt="父向子传值"></p><p><font color="pink"><strong>其中在属性前面加上：是使用了v-bind动态绑定即可以传送变量，如果不加上：则会把fatherStr作为一个字符串传送过去子组件</strong></font></p><hr><ul><li><p>子组件接收传值：</p><p><img src="https://yzaio.gitee.io/medias/images/19.jpg" alt="子接收传值"></p><p><font color="pink"><strong>在子组件中的props中进行接收父亲组件的传值</strong></font></p></li></ul><hr><ul><li><p>子向父亲传值：</p><p><img src="https://yzaio.gitee.io/medias/images/20.jpg" alt="子向父传值"></p><p><img src="https://yzaio.gitee.io/medias/images/21.jpg" alt="子向父传值"></p><p><font color="pink">子组件通过$emit发射一个函数，并可携带值，父亲组件通过绑定事件接收参数。</font></p></li></ul><h2 id="2-通过-sync实现父子组件数据双向绑定"><a href="#2-通过-sync实现父子组件数据双向绑定" class="headerlink" title="2. 通过.sync实现父子组件数据双向绑定"></a>2. 通过.sync实现父子组件数据双向绑定</h2><ul><li><p>父亲组件向子组件传值：</p><p><img src="https://yzaio.gitee.io/medias/images/22.jpg" alt="通过.sync进行传值绑定"></p><hr></li></ul><ul><li><p>子组件接收值：</p><p><img src="https://yzaio.gitee.io/medias/images/23.jpg" alt="子组件接收值并实时更新父组件绑定值"></p><p><font color="pink">子组件在接收到值后这次通过$emit发送事件加上update标识，通知父组件中与当前子组件的childStr参数绑定的变量实时更新，这样就做到了父子组件数据的双向绑定</font></p></li><li><p>最终效果如下：</p><p><img src="https://yzaio.gitee.io/medias/images/24.mkv" alt=""></p><video id="video" controls="" preload="none" poster="https://yzaio.gitee.io/medias/images/27.png">     <source id="mp4" src="https://yzaio.gitee.io/medias/images/24.mkv" type="video/mp4"></video></li></ul><h2 id="3-解决直接修改props控制台报错"><a href="#3-解决直接修改props控制台报错" class="headerlink" title="3. 解决直接修改props控制台报错"></a>3. 解决直接修改props控制台报错</h2><p>​    第二步能实现了父子组件通信数据双向绑定，但是会在控制台报以下错误</p><p><img src="https://yzaio.gitee.io/medias/images/25.jpg" alt=""></p><p>​    这个错误的导致是因为我们直接修改了props造成的警告，虽然不影响功能，但是还是需要修改一下，遵守规范</p><p>​    <font color="lightGreen">在子组件data中定义多一个变量childStr_copy来接收props的参数，可以把它当成中转值，这样我们就不会直接修改到props中的值了，修改后代码如下：</font></p><p><img src="https://yzaio.gitee.io/medias/images/26.jpg" alt=""></p><p>这样控制台的警告就消失了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中实现骨架屏</title>
      <link href="/2021/05/11/vue-zhong-shi-xian-gu-jia-ping/"/>
      <url>/2021/05/11/vue-zhong-shi-xian-gu-jia-ping/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是骨架屏"><a href="#1-什么是骨架屏" class="headerlink" title="1. 什么是骨架屏"></a>1. 什么是骨架屏</h2><p>​    骨架屏一般用于页面在请求远程数据尚未完成时，页面用灰色块预显示本来的页面结构，给用户更好的体验</p><h2 id="2-为什么需要骨架屏"><a href="#2-为什么需要骨架屏" class="headerlink" title="2.  为什么需要骨架屏"></a>2.  为什么需要骨架屏</h2><p>​    去饭店吃饭，需要排队了</p><p>​    1. 白屏：</p><p>​    饭店就只撂下一句话，我们在营业，吃饭要排队，用户等一会就不想等了</p><p>​    2. loading:</p><p>​    饭店给你取了个号，告诉你是在排队，可能很快就可以了，麻烦再等等吧</p><p>​    3. 骨架屏：</p><p>​    饭店说我是海底捞，我给你取了个号，而且给还了你零食、飞行棋、菜单让你玩着看着先，等也等得舒服一些</p><p><img src="https://yzaio.gitee.io/medias/images/17.png" alt=""></p><h2 id="3-介绍骨架屏"><a href="#3-介绍骨架屏" class="headerlink" title="3. 介绍骨架屏"></a>3. 介绍骨架屏</h2><ul><li><p>白屏时间：</p><p>前、后端分离的架构越来越备受推行，这种架构带来的便利的同时，也带来了一些弊端，比如首屏渲染时间，因为首屏需要请求更多内容，比原来多了更多HTTP的往返时间，这造成了白屏，白屏时间过长，用户体验会大打折扣，如果用户网速差，则白屏时间会更长</p></li><li><p>可以怎么优化：</p><p>白屏时间过长，我们可以做什么？</p><p>1、加速(CDN)或减少HTTP请求损耗</p><p>2、延迟加载</p><p>3、减少请求内容的体积、字体库代替图片等</p><p>4、优化用户等待的体验感</p></li></ul><h2 id="4-骨架屏实现"><a href="#4-骨架屏实现" class="headerlink" title="4.   骨架屏实现"></a>4.   骨架屏实现</h2><p>有4种实现方式</p><ul><li><ol><li><p>骨架图：</p><p>一图解决，直接找设计做一张骨架屏的图片，前端控制显隐</p><p>弊端：图片本身也属于一种加载资源，而且不灵活，每次修改骨架屏还得找设计</p></li></ol></li><li><ol start="2"><li><p>静态html、css</p><p>完全通过 HTML 和 CSS 手写的，手写骨架屏当然可以完全复刻页面的真实样式</p><p>弊端：改动了需求也需要手动维护</p></li></ol></li><li><ol start="3"><li><p>自动遍历</p><p>通过获取页面上的dom得到width、height、top、left等属性去描绘生成对应的骨架区块</p><p>弊端：并非所有场景都适用</p></li></ol></li><li><ol start="4"><li><p>半自动化</p><p>添加预备好的基础数据，渲染当前可视屏幕的骨架区块，相较于html、css维护要简单一些、也可以遍历数据之后存本地</p><p>弊端：手动维护数据</p></li></ol></li></ul><h2 id="5-使用vue-server-renderer-插件在vue种实现骨架屏"><a href="#5-使用vue-server-renderer-插件在vue种实现骨架屏" class="headerlink" title="5.  使用vue-server-renderer 插件在vue种实现骨架屏"></a>5.  使用vue-server-renderer 插件在vue种实现骨架屏</h2><p>   <font color="pink" size="5">使用vue-server-renderer可以将骨架屏代码抽离出来，使用一个 .vue 文件来 coding，之后通过配置嵌入到index.html中，易于维护。</font></p><p>​        <font color="lightGreen">实现步骤：</font></p><ol><li><p>在src下创建一个skeleton文件夹</p><p>在文件夹下创建两个文件，skeleton.entry.js和skeleton.vue</p><p><font color="lightBlue"><code>skeleton.entry.js</code> 是编译 <code>skeleton.vue</code> 的入口文件，类似于我们 Vue 项目中的 <code>main.js</code> 文件；</font></p><p><font color="lightBlue"><code>skeleton.vue</code> 就是我们的骨架屏页面的代码,用于编写我们骨架屏页面的html及css，日后需要改动就在此文件进行改动</font></p><ul><li>skeleton.entry.js文件代码：</li></ul></li></ol><pre><code>import Vue from 'vue'import Skeleton from './skeleton.vue'export default new Vue({  // 根实例简单的渲染应用程序组件  render: h =&gt; h(Skeleton)})</code></pre><ul><li>skeleton.vue文件代码：（骨架屏页面的代码，根据项目需求进行调整，这里只是示例）</li></ul><pre><code>&lt;template&gt;  &lt;div class="skeleton"&gt;    &lt;div class="head"&gt;      &lt;div class="round"&gt;&lt;/div&gt;      &lt;div&gt;        &lt;div class="line"&gt;&lt;/div&gt;        &lt;div class="line"&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class="skeletoContain"&gt;      &lt;div class="mySkeleton" v-for="item in 5" :key="item"&gt;        孙洲洋的骨架屏      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .skeleton {    padding: 20vw 5vw 5vw;  }  .head {    display: flex;    align-items: center;  }  .line {    width: 50vw;    height: 3vw;    background-color: #eeeeee;    margin-left: 3vw;  }  .head .line:nth-child(1) {    width: 30vw;    margin-bottom: 5vw;  }  .round {    width: 20vw;    height: 20vw;    border-radius: 50%;    background-color: #eeeeee;  }  .skeletoContain {    display: flex;    flex-wrap: wrap;    justify-content: space-between;    align-items: center;    margin-top: 10vw;  }  .mySkeleton {    width: 25vw;    height: 25vw;    color: lightblue;    background-color: #eee;    display: flex;    justify-content: center;    align-items: center;  }  .skeleton .mySkeleton:nth-child(n+4):nth-child(-n+5) {    border-radius: 50%;    margin-top: 10vw;  }&lt;/style&gt;</code></pre><ol start="2"><li><p>在项目根目录下创建一个webpack.skeleton.conf.js文件，这是一个 webpack 的配置文件，配合使用 <code>vue-server-renderer</code> 将我们的 <code>skeleton.vue</code> 文件内容构建为单个的 json 格式的文件（这是 Vue SSR 渲染的策略）</p><ul><li>文件代码：</li></ul></li></ol><pre><code>// webpack.skeleton.conf.js'use strict'const path = require('path')const nodeExternals = require('webpack-node-externals')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')const VueLoader = require('vue-loader/lib/plugin')module.exports = {  target: 'node',  devtool: '#source-map',  entry: './src/skeleton/skeleton.entry.js',  output: {    path: path.resolve(__dirname, './dist'),    publicPath: '/dist/',    filename: '[name].js',    libraryTarget: 'commonjs2'  },  module: {    noParse: /es6-promise\.js$/,  // avoid webpack shimming process    rules: [      {        test: /\.vue$/,        loader: 'vue-loader',        options: {          compilerOptions: {            preserveWhitespace: false          }        }      },      {        test: /\.css$/,        use: ['vue-style-loader', 'css-loader']      }    ]  },  performance: {    hints: false  },  externals: nodeExternals({    // do not externalize CSS files in case we need to import it from a dep    allowlist: /\.css$/  }),  plugins: [    // 这是将服务器的整个输出构建为单个 JSON 文件的插件。    // 默认文件名为 `vue-ssr-server-bundle.json`    new VueSSRServerPlugin({      filename: 'skeleton.json'    }),    new VueLoader()  ]}</code></pre><p>   <font size="3" color="lightGreen">此处注意一点：webpack无法打包.vue文件，需要安装相关的loader，即vue-loader，<strong>这个插件是必须的！</strong> 它的职责是将你定义过的其它规则复制并应用到 <code>.vue</code> 文件里相应语言的块。例如，如果你有一条匹配 <code>/\.js$/</code> 的规则，那么它会应用到 <code>.vue</code> 文件里的 <code>&lt;script&gt;</code> 块。 并且在<font color="red">plugins中需要把插件引入</font></font></p><ol start="3"><li><p>需要安装相关依赖</p><p>执行以下命令：</p><ul><li>npm i <a href="mailto:webpack-cli@3.3.10">webpack-cli@3.3.10</a> -D</li><li>npm i webpack-node-externals</li><li>npm i vue-server-renderer</li><li>npm i vue-loader vue-template-compiler -D</li></ul></li><li><p>在package.json中加入命令</p></li></ol><pre><code>"skeleton": "webpack --progress --config build/webpack.skeleton.conf.js"//此命令用于使用webpack-cli 运行这个 webpack.skeleton.conf.js 配置文件</code></pre><ol start="5"><li><p>执行npm run skeleton就会在根目录下创建出一个dist文件夹，其中有一个skeleton.json文件</p></li><li><p>在根目录下创建一个skeleton.js，此文件作用用于将skeleton.json文件的内容插入index.html中</p><p>skeleton.js文件代码：</p></li></ol><pre><code>// skeleton.jsconst fs = require('fs')const { resolve } = require('path')const { createBundleRenderer } = require('vue-server-renderer')function createRenderer(bundle, options) {  return createBundleRenderer(bundle, Object.assign(options, {    // recommended for performance    // runInNewContext: false  }))}const handleError = err =&gt; {  console.error(`error during render : ${req.url}`)  console.error(err.stack)}const bundle = require('./dist/skeleton.json')const templatePath = resolve('./public/index.html')const template = fs.readFileSync(templatePath, 'utf-8')const renderer = createRenderer(bundle, {  template})// console.log(renderer)/** * 说明： * 默认的index.html中包含&lt;%= BASE_URL %&gt;的插值语法 * 我们不在生成骨架屏这一步改变模板中的这个插值 * 因为这个插值会在项目构建时完成 * 但是如果模板中有这个插值语法，而我们在vue-server-renderder中使用这个模板，而不传值的话，是会报错的 * 所以，我们去掉模板中的插值，而使用这个传参的方式，再将这两个插值原模原样返回到模板中 * * 文档： https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E6%8F%92%E5%80%BC */const context = {  title: '',  // default title  meta: `&lt;meta name="theme-color" content="#4285f4"&gt;    &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;    &lt;link rel="stylesheet" href="&lt;%= BASE_URL %&gt;css/reset.css"&gt;`}renderer.renderToString(context, (err, html) =&gt; {  if(err) {    return handleError(err)  }  fs.writeFileSync(resolve(__dirname, './public/index.html'), html, 'utf-8')})</code></pre><ol start="7"><li>在index.html中修改代码增加占位符（index.html 中的 div#app 中要加一个注解插槽，<code>&lt;!--vue-ssr-outlet--&gt;</code> 这个是必须的，Vue SSR 文档中有说这个。这个注解是必须的，请注意！）（<font color="lightGreen">需要注意的是需要把index.html文件中包含的&lt;%= &gt;语法的语句去掉，在上面的skeleton.js中补充进去后面后自动生成到index.html中</font>）</li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="utf-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;  &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt; //需要去除  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; //需要去除&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;  &lt;!--vue-ssr-outlet--&gt;&lt;/div&gt;&lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="8"><li>输入命令node skeleton.js，即会把原先public中的index.html替换掉，运行项目，在network中采用slow 3g模式下可以就可以清楚看到骨架屏效果。</li></ol><p><img src="https://yzaio.gitee.io/medias/images/10.png" alt="本文章代码实现效果"></p><p>后续如果需要修改骨架屏，只需要修改skeleton.vue文件的代码，然后把index.html赋值为第7步中的原始状态，执行npm run skeleton还有node  skeleton.js命令即可</p><p><font color="pink" size="3">到此我们vue中实现骨架屏就告一段落了</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑与、逻辑或、空值合并运算符</title>
      <link href="/2021/05/10/luo-ji-yu-luo-ji-huo-kong-zhi-he-bing-yun-suan-fu/"/>
      <url>/2021/05/10/luo-ji-yu-luo-ji-huo-kong-zhi-he-bing-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑与、逻辑或、空值合并运算符"><a href="#逻辑与、逻辑或、空值合并运算符" class="headerlink" title="逻辑与、逻辑或、空值合并运算符"></a>逻辑与、逻辑或、空值合并运算符</h1><h2 id="1-逻辑与"><a href="#1-逻辑与" class="headerlink" title="1. 逻辑与"></a>1. 逻辑与</h2><ul><li><p>let  a  =  sign &amp;&amp;  ‘执行了’</p><p>如果sign为true的时候  a为执行了，如果sign为false或者nan等会使整个表达式为false的值时，会把sign作为整个表达式的返回值给a，即sign为Nan,则a为Nan，sign为false，a为false</p></li></ul><h2 id="2-逻辑或（一般用来做默认值）"><a href="#2-逻辑或（一般用来做默认值）" class="headerlink" title="2. 逻辑或（一般用来做默认值）"></a>2. 逻辑或（一般用来做默认值）</h2><ul><li><p>let a  =  sign ||  ‘执行了’</p><p>如果sign的Boolean值为true时，会把sign的值作为表达式的值返回给a，即sign为‘111’，则a为‘111’，</p><p>如果sign为false  则a为‘执行了’</p></li></ul><h2 id="3-空值合并运算符"><a href="#3-空值合并运算符" class="headerlink" title="3. 空值合并运算符"></a>3. 空值合并运算符</h2><ul><li><p><strong>空值合并操作符</strong>（<strong><code>??</code></strong>）是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#logical_or_2" target="_blank" rel="noopener">逻辑或操作符（<code>||</code>）</a>不同，逻辑或操作符会在左侧操作数为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" target="_blank" rel="noopener">假值</a>时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>''</code> 或 <code>0</code>）时。见下面的例子。</p><p>const foo = null ?? ‘default string’;<br>console.log(foo);<br>// expected output: “default string”</p><p>const baz = 0 ?? 42;<br>console.log(baz);<br>// expected output: 0  (输出为0，如果为逻辑或运算符，则为42)</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsx的实质</title>
      <link href="/2021/05/10/jsx-de-shi-zhi/"/>
      <url>/2021/05/10/jsx-de-shi-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-jsx的作用"><a href="#1-jsx的作用" class="headerlink" title="1. jsx的作用"></a>1. jsx的作用</h2><p>​    实际上，jsx 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。 </p><p>​    所有的jsx最终都会被转换成React.createElement的函数调用</p><p>​    JSX是一种JavaScript的语法扩展（eXtension），也在很多地方称之为JavaScript XML，因为看起就是一段XML语法；</p><p>​    它用于描述我们的UI界面，并且其完成可以和JavaScript融合在一起使用；</p><p>​    它不同于Vue中的模块语法，你不需要专门学习模块语法中的一些指令（比如v-for、v-if、v-else、v-bind）；</p><p>​    所以总体而言，jsx就是为了方便我们在js里面以原先html的写法去完成ui界面的书写，后期babel会自动帮我们进行转化</p><h2 id="2-React-createElement"><a href="#2-React-createElement" class="headerlink" title="2. React.createElement"></a>2. React.createElement</h2><p>​    <strong>createElement需要传递三个参数：</strong></p><ul><li><p>参数一：type</p><p>当前ReactElement的类型； </p><p>如果是标签元素，那么就使用字符串表示 “div”； </p><p>如果是组件元素，那么就直接使用组件的名称；</p></li><li><p>参数二：config</p><p>所有jsx中的属性都在config中以对象的属性和值的形式存储</p></li><li><p>参数三：children</p><p>存放在标签中的内容，以children数组的方式进行存储；</p><hr><p><strong>如以下代码的jsx通过createElement函数书写的格式：</strong></p><ul><li>这是jsx的写法<br><img src="https://yzaio.gitee.io/medias/images/7.png" alt="jsx写法"></li></ul></li><li><p>这是使用react.createElement函数的写法</p></li></ul><p><img src="https://yzaio.gitee.io/medias/images/11.png" alt="react.createElement函数的写法"></p><p>  实际上jsx只是语法糖最终打包的时候使用babel会将我们写的jsx代码转化为这种react.createElement的代码给浏览器解析，否则浏览器是无法解析这种jsx代码的</p><h2 id="3-ReactElement对象"><a href="#3-ReactElement对象" class="headerlink" title="3.  ReactElement对象"></a>3.  ReactElement对象</h2><p>  那通过react.createElement函数执行后的结果是什么呢？它就是一个ReactElement对象了。也就是我们说的虚拟dom树</p><p>  <img src="https://yzaio.gitee.io/medias/images/8.png" alt="打印一下jsx即react.CreatElement最终返回结果"></p><p>  我们在这里打印一下react.createElement的最终返回结果，得到以下</p><p>  <img src="https://yzaio.gitee.io/medias/images/9.png" alt="ReactElement对象"></p><p>  可以看到我们最终得到一个对象，它就是ReactElement对象，就是虚拟dom树了，最终再通过react.render方法才将这个虚拟dom转为真实dom</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中diff算法和列表key值的作用及与vue中diff算法的区别</title>
      <link href="/2021/05/10/react-zhong-diff-suan-fa-he-lie-biao-key-zhi-de-zuo-yong-ji-yu-vue-zhong-diff-suan-fa-de-qu-bie/"/>
      <url>/2021/05/10/react-zhong-diff-suan-fa-he-lie-biao-key-zhi-de-zuo-yong-ji-yu-vue-zhong-diff-suan-fa-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="react中diff算法和列表key值的作用及与vue中diff算法的区别"><a href="#react中diff算法和列表key值的作用及与vue中diff算法的区别" class="headerlink" title="react中diff算法和列表key值的作用及与vue中diff算法的区别"></a>react中diff算法和列表key值的作用及与vue中diff算法的区别</h1><h2 id="1-react中diff算法及列表key属性的作用"><a href="#1-react中diff算法及列表key属性的作用" class="headerlink" title="1.react中diff算法及列表key属性的作用"></a>1.react中diff算法及列表key属性的作用</h2><p>React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树。</p><p>React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI： </p><p>如果一棵树参考另外一棵树进行完全比较更新，那么即使是最先进的算法，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素</p><p>的数量； </p><p> <a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf；" target="_blank" rel="noopener">https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf；</a> </p><p>如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围； </p><p>这个开销太过昂贵了，React的更新性能会变得非常低效； </p><p>于是，React对这个diff算法进行了优化，将其优化成了O(n)，如何优化的呢？</p><p>同层节点之间相互比较，不会垮节点比较； </p><p>不同类型的节点，产生不同的树结构；</p><p>开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定；</p><hr><p><font face="逐浪立楷" color="green" size="3">下面通过三步讲下react的diff算法更新虚拟dom和真实dom机制</font></p><h3 id="情况一：对比不同类型的元素"><a href="#情况一：对比不同类型的元素" class="headerlink" title="情况一：对比不同类型的元素"></a><strong>情况一：对比不同类型的元素</strong></h3><ul><li><p>当节点为不同的元素，React会拆卸原有的树，并且建立起新的树：</p><p> 当一个元素从 a标签 变成 img标签，从 Article 变成 Comment，或从 button标签 变成 div都会触发一个完整的重建 </p><p>流程；</p><p>当卸载一棵树时，对应的DOM节点也会被销毁，组件实例将执行 componentWillUnmount() 方法； </p><p>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中，组件实例将执行 componentWillMount() 方法， </p><p>紧接着 componentDidMount() 方法； </p></li></ul><p>  比如下面的代码更改： </p><p>  React 会销毁<font color="blue">Top</font> 组件并且重新装载一个新的组件，而不会对<font color="blue">Top</font> 进行复用；</p><p>  <img src="https://yzaio.gitee.io/medias/images/13.png" alt="节点类型不同"></p><hr><p><strong>情况二：对比同一类型的元素</strong></p><ul><li>当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。</li></ul><p>  比如下面的代码更改： </p><p>  通过比对这两个元素，React 知道只需要修改 DOM 元素上的 className 属性；</p><p>  <img src="https://yzaio.gitee.io/medias/images/2.png" alt=""></p><p>  比如下面的代码更改： </p><p>  当更新 style 属性时，React 仅更新有所更变的属性。</p><p>  通过比对这两个元素，React 知道只需要修改 DOM 元素上的 color 样式，无需修改 fontWeight。 </p><p>  <img src="https://yzaio.gitee.io/medias/images/3.png" alt=""></p><p>  如果是同类型的组件元素： </p><p>  组件会保持不变，React会更新该组件的props，并且调用componentWillReceiveProps() 和 componentWillUpdate() 方 </p><p>  法； </p><p>  下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归；</p><hr><p><strong>情况三：对子节点进行递归</strong></p><p>在默认条件下，当递归 DOM 节点的子元素时，React 会同</p><p>时遍历两个子元素的列表；当产生差异时，生成一个</p><p>mutation。 </p><p>我们来看一下在最后插入一条数据的情况： </p><p><img src="https://yzaio.gitee.io/medias/images/5.png" alt=""></p><p>前面两个比较是完全相同的，所以不会产生mutation； </p><p>最后一个比较，产生一个mutation，将其插入到新的</p><p>DOM树中即可；</p><p>但是如果我们是在中间插入一条数据：</p><p><img src="https://yzaio.gitee.io/medias/images/14.png" alt="img"></p><p>这样react中新树的第一项与旧树的第一项进行比较，不对应，产生一个mutation，以此类推，</p><p>React会对每一个子元素产生一个mutation，则是三个mutation而不是保持 </p><li>first</li>和<li>second</li>的不变；<p></p><p>这种低效的比较方式会带来一定的性能问题；</p><p><font color="pink">所以为了解决这种低效的性能问题，可以加入keys的优化</font></p><p>我们在react中遍历列表时，在字元素不加key属性的话总是会提示一个警告，让我们加入一个key属性：</p><ul><li>方式一：在最后位置插入数据</li></ul><p>这种情况，有无key意义并不大</p><ul><li><p>方式二：在前面插入数据</p><ul><li>这种做法，在没有key的情况下，所有的li都需要进行修改； </li></ul></li></ul><p><img src="https://yzaio.gitee.io/medias/images/6.png" alt=""></p><p>当子元素(这里的li)拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素： </p><p>在下面这种场景下，key为111和222的元素仅仅进行位移，不需要进行任何的修改； </p><p>将key为333的元素插入到最前面的位置即可；</p><ul><li><em>key的注意事项</em>： </li></ul><p>key应该是唯一的；</p><p>key不要使用随机数（随机数在下一次render时，会重新生成一个数字）； </p><p>使用index作为key，对性能是没有优化的；</p><h2 id="2-vue中diff算法与react中diff算法区别"><a href="#2-vue中diff算法与react中diff算法区别" class="headerlink" title="2. vue中diff算法与react中diff算法区别"></a>2. vue中diff算法与react中diff算法区别</h2><ol><li>vue中diff算法在对新老虚拟daom进行对比时，是从节点的两侧向中间对比，而react是从节点左侧开始对比，就好比将新老虚拟dom放入两个栈中，一对多依次对比；</li><li>vue中在进行节点比较时节点的key值与元素类型相同，属性值不同，就会认为是不同节点，就会删除重建，而react中节点的key值与元素类型相同，属性值不同，react会认为是同类型节点，只是修改节点属性</li></ol><ul><li><p>两者的共同点：</p><p>都只进行同级比较，忽略了跨级操作；常见的现象就是对数组或者对象中的深层元素进行修改时，视图层监测不到其变化，故不会对dom进行更新，需调用一些特质方法来告诉视图层需要更新dom</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端日常知识点</title>
      <link href="/2021/04/13/qian-duan-ri-chang-zhi-shi-dian/"/>
      <url>/2021/04/13/qian-duan-ri-chang-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="前端日常知识点"><a href="#前端日常知识点" class="headerlink" title="前端日常知识点"></a>前端日常知识点</h1><h2 id="1-CSS3的到来引入了一个非常有用的功能，就是calc-函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备-电脑，平板，手机-，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局"><a href="#1-CSS3的到来引入了一个非常有用的功能，就是calc-函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备-电脑，平板，手机-，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局" class="headerlink" title="1. CSS3的到来引入了一个非常有用的功能，就是calc()函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备(电脑，平板，手机)，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局"></a>1. CSS3的到来引入了一个非常有用的功能，就是<code>calc()</code>函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在<a href="https://www.webhek.com/misc/responsive-web-design" target="_blank" rel="noopener">自适应网页布局设计</a>中格外有用——针对不同尺寸的设备(电脑，平板，手机)，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局</h2><p>如以下写法</p><pre><code>height： calc(50% - 20px)//则高度为父盒子高度再减去20px</code></pre><p>这个计算器有个注意点 ：  就是calc()内部算法中间运算符需使用空格分隔否则不会生效</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组常用高阶语法</title>
      <link href="/2021/04/09/shu-zu-chang-yong-gao-jie-yu-fa/"/>
      <url>/2021/04/09/shu-zu-chang-yong-gao-jie-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数组常用高阶语法"><a href="#数组常用高阶语法" class="headerlink" title="数组常用高阶语法"></a>数组常用高阶语法</h1><h2 id="1-map方法"><a href="#1-map方法" class="headerlink" title="1. map方法"></a>1. map方法</h2><p>返回值为一个数组，可以对数组每一项进行处理并ruturn返回作为新数组的元素<br>可以传入三个参数</p><ul><li>第一个参数为当前元素的值</li><li>第二个参数为当前元素索引值</li><li>第三个参数为整个数组</li></ul><p>示例如下</p><pre><code>let arr = [1,2,3]let newArr = arr.map((item,index,arr) =&gt; {  return arr + 1})则arr就变为 [2,3,4]</code></pre><h2 id="2-filter方法"><a href="#2-filter方法" class="headerlink" title="2. filter方法"></a>2. filter方法</h2><p>返回值为一个数组，可以对数组每一项进行检查判断，把检查完为true的元素ruturn返回作为新数组的元素<br>可以传入三个参数（与map一致）</p><ul><li>第一个参数为当前元素的值</li><li>第二个参数为当前元素索引值</li><li>第三个参数为整个数组</li></ul><pre><code>let arr = [1,2,3]let newArr = arr.map((item,index,arr) =&gt; {  return arr &gt; 1})则arr就变为 [2,3]</code></pre><h2 id="3-reduce方法"><a href="#3-reduce方法" class="headerlink" title="3. reduce方法"></a>3. reduce方法</h2><p>返回值为循环结束后return出来的累加值，可以作为一个累加器<br>可以传入两个参数</p><ul><li>第一个参数为回调函数<ul><li>回调函数的参数<ul><li>第一个参数： 上一次回调函数的结果（第一次没有上一次函数的回调函数的结果, 使用初始化值即是reduce方法的第二个参数）</li><li>第二个参数为当前元素的值</li><li>第三个参数为当前元素索引值</li><li>第四个参数为整个数组</li></ul></li></ul></li><li>第二个参数为初始值</li></ul><pre><code>let arr = [1,2,3]let total = arr.reduce((preValue,item,index,arr) =&gt; {  return preValue + item},10)则total最终结果为10 + 1 + 2 + 3 = 16</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react学习</title>
      <link href="/2021/04/07/react-xue-xi/"/>
      <url>/2021/04/07/react-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="react学习"><a href="#react学习" class="headerlink" title="react学习"></a>react学习</h1><h2 id="1-jsx本质"><a href="#1-jsx本质" class="headerlink" title="1. jsx本质"></a>1. jsx本质</h2><ul><li>jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.    render -&gt; 真实DOM<br> jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.rensder -&gt; 原生的控件(UIButton/Button)</li></ul><h2 id="2-使用虚拟dom的好处"><a href="#2-使用虚拟dom的好处" class="headerlink" title="2.使用虚拟dom的好处"></a>2.使用虚拟dom的好处</h2><ul><li>jq和原生js等是直接操作真是Dom进行修改页面，而react是用一个jascript对象的虚拟Dom先来描述ui，再使用ReactDom.render来将虚拟dom转化成真实dom形成页面，这样可以避免了频繁操作真实dom树，提高性能，因为本来document.creatElement这个方法创建出来的Dom就是很复杂的东西，而ReactElemnt对象要比它简单很多。</li></ul><h2 id="3-React中设计原则-state中的数据的不可变性"><a href="#3-React中设计原则-state中的数据的不可变性" class="headerlink" title="3. React中设计原则: state中的数据的不可变性;"></a>3. React中设计原则: state中的数据的不可变性;</h2><ul><li><p>即是在修改state中的数据时，不要去修改到原来内部的数据项</p><p><font color="lightGreen">原因是当我们组件是继承自pureComponent或者自己书写的对比前后state是否改变来决定组件是否渲染的高阶组件时，我们如果在setState修改state数据时，先改变了原来的state值得话，有时会造成组件不会重新渲染render的风险，所以我们在进行setState修改数据时，应该遵守state中的数据的不可变性</font></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目知识点</title>
      <link href="/2021/03/31/vue-xiang-mu-zhi-shi-dian/"/>
      <url>/2021/03/31/vue-xiang-mu-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="vue项目知识点"><a href="#vue项目知识点" class="headerlink" title="vue项目知识点"></a>vue项目知识点</h1><h2 id="1-页面前进后退不刷新问题"><a href="#1-页面前进后退不刷新问题" class="headerlink" title="1.  页面前进后退不刷新问题"></a>1.  页面前进后退不刷新问题</h2><ul><li><p>页面使用hash模式时页面使用网页的前进后退会出现地址栏地址变化但是不刷新的情况，在全局添加Bom事件操作如下来解决问题</p><p>  window.addEventListener(‘hashchange’, () =&gt; {</p><p>  let currentPath = window.location.hash.slice(1)</p><p>  if (this.$route.path !== currentPath) {</p><p>  this.$router.push(currentPath)</p><p>  }</p><p>  }, false)</p></li></ul><hr><h2 id="2-禁止缩放方法"><a href="#2-禁止缩放方法" class="headerlink" title="2. 禁止缩放方法"></a>2. 禁止缩放方法</h2><ul><li><p>可以在index.html页面加上以下代码禁止页面缩放</p><p><code>&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;</code></p></li></ul><hr><h2 id="3-watch监听数组不更新问题"><a href="#3-watch监听数组不更新问题" class="headerlink" title="3. watch监听数组不更新问题"></a>3. watch监听数组不更新问题</h2><ul><li><p>watch对于数组或者对象在某些特定情况下是无法监听到的。这种情况其实和双向绑定的原理有关。Vue双向绑定原理是利用js中的Object.defineproperty重定义对象的GET和SET方法，而同时这种方法存在着缺陷，就是只能监听到对象内已有的值，如果需要改变数组中某个值被监听到的话，直接通过数组的index然后去改变的话无法在watch里面监听到，可以通过临时变量中转的方法：</p><p>  let tempArr = […this.targetArr]</p><p>  tempArr[0] = {data: ‘test’}</p><p>  this.targetArr = tempArr</p></li></ul><hr><h2 id="4-上传文件接口参数问题"><a href="#4-上传文件接口参数问题" class="headerlink" title="4. 上传文件接口参数问题"></a>4. 上传文件接口参数问题</h2><ul><li>批量导入的文件上传不能使用平常的数据类型传参，在axios请求中还需要定义header头部的Content-Type来更换此请求为文件上传类型，传参对象需要new一个FormData，把需要传参得数据，通过append方法加进去</li></ul><p><code>'Content-Type': 'multipart/form-data; boundary = ' + new Date().getTime()</code> </p><hr><h2 id="5-移动端解决300ms延迟"><a href="#5-移动端解决300ms延迟" class="headerlink" title="5.移动端解决300ms延迟"></a>5.移动端解决300ms延迟</h2><ul><li><p>移动端为了识别用户单击双击会在用户第一次点击的时候产生300ms延迟，为了解决这个延迟，可以使用第三方包fastclick，通过npm安装后，在项目的main.js中引入，并使用它其中的attach方法fastclick.attach(document.body)来解决延迟。</p><p>使用fastclick包</p><pre><code>1. npm install fastclick --save2. 在mian.js中使用</code></pre><p>  import FastClick from ‘fastclick’<br>  //使用包其中的attach方法<br>  FastClick.attach(document.body)</p></li></ul><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ie11踩坑点</title>
      <link href="/2021/03/31/ie11-cai-keng-dian/"/>
      <url>/2021/03/31/ie11-cai-keng-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="ie11踩坑点"><a href="#ie11踩坑点" class="headerlink" title="ie11踩坑点"></a>ie11踩坑点</h1><h5 id="1-Ie11对于new-Date（）里面的值如果是用-分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题"><a href="#1-Ie11对于new-Date（）里面的值如果是用-分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题" class="headerlink" title="1. Ie11对于new Date（）里面的值如果是用/分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题"></a>1. Ie11对于new Date（）里面的值如果是用/分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题</h5><hr><h5 id="2-ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。"><a href="#2-ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。" class="headerlink" title="2. ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。"></a>2. ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置代理的注意点</title>
      <link href="/2021/03/31/webpack-pei-zhi-dai-li-de-zhu-yi-dian/"/>
      <url>/2021/03/31/webpack-pei-zhi-dai-li-de-zhu-yi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="使用webpack代理服务的注意点"><a href="#使用webpack代理服务的注意点" class="headerlink" title="使用webpack代理服务的注意点"></a>使用webpack代理服务的注意点</h1><p> 使用webpack配置代理访问解决跨域问题时，检索地址名如果与路由活跃 地址有相同时，会导致该路由页面刷新不存在，并且无法直接用该路由地址 访问页面，通过修改wenbpack配置内部的检索地址名或者改变路由活跃路 径解决问题。</p><h2 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h2><p><img src="https://yzaio.gitee.io/medias/images/12.png" alt=""><br><strong><em>代理服务使用了test作为配置路径</em></strong><br>如果在路由内部使用了/test作为前端路由路径的话，使用push跳转不会出现错误，但是当刷新页面或者使用/test直接作为地址访问页面无法找到。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element踩坑注意</title>
      <link href="/2021/03/31/element-cai-keng-zhu-yi/"/>
      <url>/2021/03/31/element-cai-keng-zhu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="element踩坑点"><a href="#element踩坑点" class="headerlink" title="element踩坑点"></a>element踩坑点</h1><ol><li>使用element输出框并且增加标签属性required的时候，出现输入框输入字符后再删到无字符情况下会校验出现英文状态，需要去掉此属性来解决问题。</li></ol><hr><ol start="2"><li>使用element组件校验规则要校验多选框的时候，不能在created周期内定义空数组，反正会出现校验bug，需要先给另外一个变量定义数组后赋值到该项上就可以</li></ol><hr><ol start="3"><li>Element组件库的cascader组件在ie11下，如果数据项字段太长会出现显示不全的状况，通过加入以下代码改变下拉框的宽度来解决问题<br><code>@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) { .el-cascader__dropdown .el-cascader-menu { width: 320px !important; } }</code></li></ol><ul><li>其中320px为可改变值  根据自身项目数据的长度去进行调整</li></ul><hr><ol start="4"><li><p>项目使用elementui组件库的时候，因为设计可能采用的主题色不同，需要修改大部分element组件的默认色的话，可以使用scss来进行全局统一修改，通过安装主题修改器来生成并修改scss文件，修改element默认主题色，代码如下(<a href="https://element.eleme.cn/#/zh-CN/component/custom-theme" target="_blank" rel="noopener">更具体可参考element官网更换主题步骤</a>)：</p><ul><li>cd element-demo</li><li>npm i element-theme -g</li><li>npm i element-theme-chalk -D</li><li>et -i</li><li>修改scss中的颜色值</li><li>et   </li></ul></li></ol><hr><ol start="5"><li>element的select组件在ie11上打开还有关闭会闪现滚动条，通过在该vue文件最外层div定义样式超出省略overflow-x: hidden;overflow-y:visible!important;解决问题。</li></ol><hr><ol start="6"><li>标签超过省略展示更多的按钮或者文字如果要放在文字同一行，不能单纯使用-webkit-line-clamp:2的方法，需要操作相应标签dom节点获取标签的自带的原生方法getClientRects（），通过数组长度来判定行数，再切割我们需要行数的字符数，把展示更多的按钮或者文字塞到同一行</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>臭猪头，对不起，好好的</title>
      <link href="/2020/06/21/chou-zhu-tou-dui-bu-qi-hao-hao-de/"/>
      <url>/2020/06/21/chou-zhu-tou-dui-bu-qi-hao-hao-de/</url>
      
        <content type="html"><![CDATA[<h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><ul><li>徐文莉</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>猪</li></ul><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2256160164,2873615387&amp;fm=26&amp;gp=0.jpg" alt="开心一点"></p><h2 id="对不起，让你受了这么多伤"><a href="#对不起，让你受了这么多伤" class="headerlink" title="对不起，让你受了这么多伤"></a>对不起，让你受了这么多伤</h2><p><img src="https://yzaio.gitee.io/medias/images/111.mp4" alt=""><br><img src="https://yzaio.gitee.io/medias/images/2.jpg" alt=""><br><img src="https://yzaio.gitee.io/medias/images/111.mkv" alt=""></p><video id="video" controls="" preload="none" poster="https://yzaio.gitee.io/medias/images/2.jpg">     <source id="mp4" src="https://yzaio.gitee.io/medias/images/111.mkv" type="video/mp4"></video>-555<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型与复杂数据类型及类型判别</title>
      <link href="/2020/06/12/ji-ben-shu-ju-lei-xing-yu-fu-za-shu-ju-lei-xing-ji-lei-xing-pan-bie/"/>
      <url>/2020/06/12/ji-ben-shu-ju-lei-xing-yu-fu-za-shu-ju-lei-xing-ji-lei-xing-pan-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本数据类型"><a href="#一-基本数据类型" class="headerlink" title="一. 基本数据类型"></a>一. 基本数据类型</h2><ol><li>基本数据类型有<br>string number boolean nul undefined<ul><li>他们赋值的时候是保存在栈里面的</li></ul></li></ol><ul><li><p>当出现相互赋值的以下情况<br>var a = 1<br>var b = a<br><strong>这个时候只是把a的值赋值给b，两者变量存放的地址并不相同，所以两者改变自己的值另外一方不受影响</strong></p><p><img src="https://yzaio.gitee.io/medias/images/15.png" alt="基本数据类型"></p><h2 id="二-复杂数据类型"><a href="#二-复杂数据类型" class="headerlink" title="二. 复杂数据类型"></a>二. 复杂数据类型</h2><ol start="2"><li>复杂数据类型<br>object array function<ul><li>他们赋值声明的时候，是保存在堆里面的，而且和基本数据类型不同的是我们给基本数据类型赋值的时候就是直接把值赋过去，但是我们给复杂数据类型赋值的时候是在堆中为它开辟一个内存地址用于存放数据，而我们只是把这个数据的存放的内存地址赋值给这个复杂数据类型</li><li>所以当出现以下情况，以对象为例子<br>var obj = {name: ‘kobe’}<br>var newObj = obj<br>newObj.name = ‘wade’<br>console.log(obj) //{name: ‘wade’}<br>//这个时候我们是把obj的内存地址给到了newObj，所以两个变量都同时指向这个区域，当任何一方发生改变的时候，另外一方也会发生改变<br><img src="https://yzaio.gitee.io/medias/images/16.png" alt="复杂数据类型"></li></ul></li></ol></li></ul><h2 id="三-类型判别"><a href="#三-类型判别" class="headerlink" title="三.  类型判别"></a>三.  类型判别</h2><ul><li><p>使用typeof可以判别简单数据类型，对于复杂数据类型无法精准判别，只会输出object</p><p>所以我们可以使用到js中的Object.prototype.toString.call方法，下面是它的作用：</p><p>var  gettype=Object.prototype.toString</p><p>gettype.call(‘aaaa’)输出   [object String]</p><p>gettype.call(2222) 输出   [object Number]</p><p>gettype.call(true) 输出   [object Boolean]</p><p>gettype.call(undefined) 输出   [object Undefined]</p><p>gettype.call(null) 输出  [object Null]</p><p>gettype.call({})  输出  [object Object]</p><p>gettype.call([])  输出  [object Array]</p><p>gettype.call(function(){})   输出  [object Function]</p></li><li><p><font color="pink">所以我们可以封装一个方法来对类型进行判别</font></p></li><li><p>封装isType函数如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let isType = type =&gt; obj =&gt; {</span><br><span class="line">  console.log(obj)</span><br><span class="line">  console.log(type)</span><br><span class="line">  return Object.prototype.toString.call( obj ) === '[object ' + type + ']';</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接下来使用函数看看效果（对于简单数据类型和复杂数据类型都可检测）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(isType('String')(111)); //false</span><br><span class="line">console.log(isType('Function')(function test() {</span><br><span class="line"></span><br><span class="line">})) // true</span><br><span class="line">console.log(isType('Object')([])) // false</span><br><span class="line">console.log(isType('Array')([]))  // true</span><br><span class="line">console.log(isType('Object')({})) // true</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
